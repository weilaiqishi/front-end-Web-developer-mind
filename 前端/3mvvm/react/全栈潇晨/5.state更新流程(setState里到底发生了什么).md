# 5.state更新流程(setState里到底发生了什么)

教程地址
<https://xiaochen1024.com/article_item/600acba1245877002ed5deff>

上一节我们介绍了react两种模式的入口函数到render阶段的调用过程，也就是mount首次渲染的流程
介绍在更新状态之后到render阶段的流程

状态更新整体流程
![状态更新整体流程](https://gitee.com/xiaochen1024/assets/raw/master/assets/_18.png)

触发更新->创建Update->从更新的`fiber节点`向上遍历到`rootFiber`->调度->render阶段->commit阶段

## 触发更新

### 在react中触发状态更新的几种方式

- ReactDOM.render
- this.setState
- this.forceUpdate
- useState
- useReducer

### this.setState和this.forceUpdate

1.this.setState内调用this.updater.enqueueSetState

2.this.forceUpdate和this.setState一样，只是会让tag赋值ForceUpdate
如果标记ForceUpdate，render阶段组件更新会根据checkHasForceUpdateAfterProcessing，和checkShouldComponentUpdate来判断，如果Update的tag是ForceUpdate，则checkHasForceUpdateAfterProcessing为true，当组件是PureComponent时，checkShouldComponentUpdate会浅比较state和props，所以当使用this.forceUpdate一定会更新

3.enqueueForceUpdate之后会经历创建update，调度update等过程，接下来就来讲这些过程

## 创建Update

​HostRoot或者ClassComponent触发更新后，会在函数createUpdate中创建update，并在后面的render阶段的beginWork中计算Update。FunctionComponent对应的Update在第11章讲，它和HostRoot或者ClassComponent的Update结构有些不一样

``` js
export function createUpdate(eventTime: number, lane: Lane): Update<*> {//创建update
  const update: Update<*> = {
    eventTime,
    lane,
  
    tag: UpdateState,
    payload: null,
    callback: null,
  
    next: null,
  };
  return update;
}
```

- lane：优先级（第12章讲）
- tag：更新的类型，例如UpdateState、ReplaceState
- payload：ClassComponent的payload是setState第一个参数，HostRoot的payload是ReactDOM.render的第一个参数
- callback：setState的第二个参数
- next：连接下一个Update形成一个链表，例如同时触发多个setState时会形成多个Update，然后用next 连接

### updateQueue

​对于HostRoot或者ClassComponent会在mount的时候使用initializeUpdateQueue创建updateQueue，然后将updateQueue挂载到fiber节点上

```js
export function initializeUpdateQueue<State>(fiber: Fiber): void {
  const queue: UpdateQueue<State> = {
    baseState: fiber.memoizedState,
    firstBaseUpdate: null,
    lastBaseUpdate: null,
    shared: {
      pending: null,
    },
    effects: null,
  };
  fiber.updateQueue = queue;
}
```

- baseState：初始state，后面会基于这个state，根据Update计算新的state
- firstBaseUpdate、lastBaseUpdate：Update形成的链表的头和尾
- shared.pending：新产生的update会以单向环状链表保存在shared.pending上，计算state的时候会剪开这个环状链表，并且链接在lastBaseUpdate后
- effects：calback不为null的update

## 从fiber节点向上遍历到rootFiber

​在markUpdateLaneFromFiberToRoot函数中会从触发更新的节点开始向上遍历到rootFiber，遍历的过程会处理节点的优先级

```js
 function markUpdateLaneFromFiberToRoot(
    sourceFiber: Fiber,
    lane: Lane,
  ): FiberRoot | null {
    sourceFiber.lanes = mergeLanes(sourceFiber.lanes, lane);
    let alternate = sourceFiber.alternate;
    if (alternate !== null) {
      alternate.lanes = mergeLanes(alternate.lanes, lane);
    }
    let node = sourceFiber;
    let parent = sourceFiber.return;
    while (parent !== null) {//从触发更新的节点开始向上遍历到rootFiber
      parent.childLanes = mergeLanes(parent.childLanes, lane);//合并childLanes优先级
      alternate = parent.alternate;
      if (alternate !== null) {
        alternate.childLanes = mergeLanes(alternate.childLanes, lane);
      } else {
      }
      node = parent;
      parent = parent.return;
    }
    if (node.tag === HostRoot) {
      const root: FiberRoot = node.stateNode;
      return root;
    } else {
      return null;
    }
  }
```

## 调度

在`ensureRootIsScheduled`中，`scheduleCallback`会以一个`优先级`调度`render阶段`的`开始函数performSyncWorkOnRoot或者performConcurrentWorkOnRoot`

```js
if (newCallbackPriority === SyncLanePriority) {
  // 任务已经过期，需要同步执行render阶段
  newCallbackNode = scheduleSyncCallback(
    performSyncWorkOnRoot.bind(null, root)
  );
} else {
  // 根据任务优先级异步执行render阶段
  var schedulerPriorityLevel = lanePriorityToSchedulerPriority(
    newCallbackPriority
  );
  newCallbackNode = scheduleCallback(
    schedulerPriorityLevel,
    performConcurrentWorkOnRoot.bind(null, root)
  );
}
```

## 状态更新

classComponent状态计算发生在processUpdateQueue函数中，涉及很多链表操作

- 初始时fiber.updateQueue单链表上有firstBaseUpdate（update1）和lastBaseUpdate（update2），以next连接
- fiber.updateQueue.shared环状链表上有update3和update4，以next连接互相连接
- 计算state时，先将fiber.updateQueue.shared环状链表‘剪开’，形成单链表，连接在fiber.updateQueue后面形成baseUpdate
- 然后遍历按这条链表，根据baseState计算出memoizedState

![classComponent状态计算](https://gitee.com/xiaochen1024/assets/raw/master/assets/_19.png)

### 带优先级的状态更新

假设有c1/c2低优先级任务先发生，c3高优先级任务后发生

- 通过ReactDOM.render创建的应用没有优先级的概念，类比git提交，相当于先commit，然后提交c3
- 在concurrent模式下，类似git rebase，先暂存之前的代码，在master上开发，然后rebase到之前的分支上

优先级是由Scheduler来调度的，这里我们只关心状态计算时的优先级排序，也就是在函数processUpdateQueue中发生的计算

> 例如初始时有c1-c4四个update，其中c1和c3为高优先级
> 在第一次render的时候，低优先级的update会跳过，所以只有c1和c3加入状态的计算
> 在第二次render的时候，会以第一次中跳过的update（c2）之前的update（c1）作为baseState，跳过的update和之后的update（c2，c3，c4）作为baseUpdate重新计算

在concurrent模式下，componentWillMount可能会执行多次，变现和之前的版本不一致

fiber.updateQueue.shared会同时存在于workInprogress Fiber和current Fiber，目的是为了防止高优先级打断正在进行的计算而导致状态丢失，这段代码也是发生在processUpdateQueue中
