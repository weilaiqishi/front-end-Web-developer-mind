# context

课程地址
<https://xiaochen1024.com/courseware/60b1b2f6cf10a4003b634718/60b1b564cf10a4003b634729>

context流程图
![context流程图](https://topfullstackkimeng.oss-cn-hangzhou.aliyuncs.com/md/react/react%20context%20provide.png)
![context流程图2](https://xiaochen1024.com/20210529105954.png)

## cursor/valueStack

react源码中存在一个 `valueStack` 和 `valueCursor` 用来记录 `context` 的历史信息和 `当前context`，另外还有一个 `didPerformWorkStackCursor` 用来表示当前的 `context` 有没有变化

```js
//ReactFiberNewContext.new.js
const valueCursor: StackCursor<mixed> = createCursor(null);
...
const didPerformWorkStackCursor: StackCursor<boolean> = createCursor(false);
```

```js
//ReactFiberStack.new.js
const valueStack: Array<any> = [];
...
function pushProvider(providerFiber, nextValue) {
  var context = providerFiber.type._context;
  {
    push(valueCursor, context._currentValue, providerFiber);
    context._currentValue = nextValue;
  }
}
...
function popProvider(providerFiber) {
  var currentValue = valueCursor.current;
  pop(valueCursor, providerFiber);
  var context = providerFiber.type._context;

  {
    context._currentValue = currentValue;
  }
}
```

在 `render阶段` 调用 `updateContextProvider` 的时候会执行 `pushProvider` ，将新的值push进 `valueStack` 中

在 `commit阶段` 调用 `completeWork` 的时候会执行 `popProvider` ，将 `栈顶context` `pop` 出来

为什么会有这样一个机制呢，因为我们的 `context` 是 `跨层级的`，在之前讲到 `render阶段` 和 `commit阶段` 的时候，我们会以深度优先遍历的方式遍历节点，如果涉及跨层级读取状态就有点力不从心了，就需要一层一层往下传递我们的props，所以我们可以用一个 `stack` 记录我们的 `context` ，在 `render阶段` `pushProvider` ，在 `commit阶段` `popProvider`，在每个具体的层级能根据 `valueCursor` 取 `当前value`

## createContext

`context` 和 `Provider`、`Consumer` 的关系是这样的

```js
context.Provider = {
    $$typeof: REACT_PROVIDER_TYPE,
    _context: context,
  };
context.Consumer = context;
```

## useContext

`useContext` 会调用 `readContext` ，`readContext` 会创建 `dependce` ，加入当前 `fiber` 的 `dependencies` 链表中

## provider/customer

在 `render阶段` 会调用 `updateContextProvider` ，注意几个关键的步骤

- `pushProvider`：将当前 `context` 加入 `valueStack`
- `calculateChangedBits`：`useContext` 可以设置 `observedBits` ，没有设置的话就是 `MAX_SIGNED_31_BIT_INT` ，也就是31位1，用于计算 `changedBits`，这个计算 `context` 是否变化的过程就发生在`calculateChangedBits` 函数中，用这样的方式可以提高 `context` 变化之后的性能
- `bailoutOnAlreadyFinishedWork/propagateContextChange`：如果 `changedBits` 没有改变则走 `bailoutOnAlreadyFinishedWork` 的逻辑，跳过当前节点的更新，如果改变则执行 `propagateContextChange`

`updateContextConsumer` 执行 `prepareToReadContext` 判断优先级是否足够加入当前这次 `render` ，`readContext` 取到当前 `context` 的 `value`
