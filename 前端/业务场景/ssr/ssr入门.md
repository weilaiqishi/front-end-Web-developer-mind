# ssr入门

参考文章

- [什么是服务端渲染](http://doc.ssr-fc.com/docs/features$ssr)
- [从头开始，彻底理解服务端渲染原理(8千字汇总长文)](https://juejin.cn/post/6844903881390964744)

## CSR、 SSR、 SSG 和 ISR

客户端渲染CSR、服务器端渲染SSR、静态网站生成SSG、增量静态再生ISR

`SSR` 解决了 `SEO` 问题并且加快了应用尤其是单页面应用的首屏加载速度，而对于某些内容不常变化的静态页面，我们还能采用静态网站生成 `(Static Site Generation/SSG)` 的方式，让网页在打包的过程中就生成好，用户请求时直接将网页传给客户端

但 `SSG` 往往会有这样的问题：内容变了需要重新打包项目发布，否则用户会看到过时的数据，不仅如此，如果我有多个产品需要做推广，我们的路由往往是.../products/productId，这时如果有一个新增的产品然后发现服务器上没有对应的静态文件呢，再重新打包吗？或许我们可以采用服务端渲染的方式，但 `ISR` 更是一个不错的选择。
`ISR` 即增量式的网站渲染，顾名思义，服务端发现找不到productId对应的html文件，那么它会认为其为增量数据，并立即对其进行静态网页生成, 这样下次客户端请求这个产品时就可以直接返回这个新的html了。

## 什么是服务端渲染

### 同构开发

同构开发在大前端中指的是使用相同的代码支持同时运行于服务端和客户端。区别于传统的 `JSP/ASP` 以及 `template + data => html + 前端 jQuery`, 原生 `JS` 获取 `DOM` 绑定事件的服务端渲染方式我们称之为前后端异构。同构渲染指的是组件可以在服务端运行，生成 `html`，再由客户端 `Vue/React` 接管从服务端吐出的 html，使其变为由客户端 Vue/React 管理的动态 `DOM` 的生成过程。

#### 演变过程

前端的演变过程

1. 最初的 Java、PHP 时代的纯服务端渲染时代
2. 前后端分离，即使用 JavaScript 运行在客户端，通过请求获取服务端接口数据，借助如 jQuery、Angular、React、Vue 等前端框架操作或生成页面 DOM，充分利用客户端资源，减少服务端压力，前后端分工明确，一直到现在仍是最常用的开发方式。
3. 同构开发，如 Next.js、Nuxt.js 等框架以及本文档介绍的 ssr 框架，都提供了不同的适用场景和开发方式，但目的都是为了同一套代码能同时应用于服务端和客户端。

SSR 演变过程

1. JSP/ASP/Smarty 都算，当然 Node 渲染模板也算，Node 世界模板最为丰富
2. bigpipe，虽然很老了，但分块传输优点是非常明显的，且浏览器友好。fb和微博，qunar都是受益者。Node天然支持，res.write 很友好
3. 基于组件写法的SSR，比如 `React SSR`, `Vue SSR`。时代变了，`SSR`也要跟上。`vdom + hydrate` 可以非常舒适的结合
4. 真正的同构，即 CSR 和 SSR 写法一致，未来不再区分概念，在 serverless 里，`api和渲染` 都是函数。

#### 同构开发的需要考量的点

- 代码或框架层面需要兼容 server/client 的 runtime。比较直接的一个就是 `fetch` 数据操作，如果服务端数据源有 `rpc` 协议或请求的服务存在环境/网络隔离，此时运行在客户端就获取不到数据，`需要把 rpc 或存在环境/网络隔离的请求封装成通用的 http 接口`，或者一些前端使用的库无法在后端运行，这些问题需要都进行特殊处理。
- 更复杂的部署和打包构建。部署和打包构建过程加倍，简单的理解就是单独的 server 和单独的 client 的工作总和。
- 增加服务端负载。这个“缺点”严格上是传统 SSR 的通病，但使用同构开发方式后完全可以变成了一个可优化的点。在使用同构方式时，可以针对服务端资源负载做监控，如果遇到有服务端负载过大或高峰时段，可以将渲染方式无缝切换成 CSR，待服务端负载正常或流量回落时再切换为 SSR。

#### 同构开发的优点

- 服务端和客户端共用代码
- 更快的页面内容到达时间
- 更友好的 SEO
- 更优雅的降级方式，更健壮的应用