# 小程序面试题

## Taro

### Taro3跨端跨框架原理

[Taro3跨端跨框架原理初探](https://juejin.cn/post/6989968343163731981)

#### Taro3之前（重编译时，轻运行时）

![Taro12架构图](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7a7325c8843c47c688395192749a1e31~tplv-k3u1fbpfcp-watermark.awebp)

编译时是使用 `babel-parser` 将 Taro 代码解析成抽象语法树，然后通过 `babel-types` 对抽象语法树进行一系列修改、转换操作，最后再通过 `babel-generate` 生成对应的目标代码。

编译时缺点

- JSX ⽀持程度不完美。Taro 对 JSX 的⽀持是通过编译时的适配去实现的，但 JSX ⼜⾮常之灵活，因此还不能做到 100% ⽀持所有的 JSX 语法。 JSX 是一个 JavaScript 的语法扩展，它的写法千变万化，十分灵活。之前Taro团队是采用穷举的方式对 JSX 可能的写法进行了一一适配，这一部分工作量很大。
- 不⽀持 source-map。Taro 对源代码进⾏了⼀系列的转换操作之后，就不⽀持 source-map 了，⽤户 调试、使⽤这个项⽬就会不⽅便。
- 维护和迭代⼗分困难。Taro 编译时代码⾮常的复杂且离散，维护迭代都⾮常的困难。

运⾏时的缺陷

对于每个⼩程序平台，都会提供对应的⼀份运⾏时框架进⾏适配。当修改⼀些 Bug 或者新增⼀些特性的时候，需要同时去修改多份运⾏时框架。

#### Taro3之后（重运行时）

![Taro3架构图](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/462297be6ab44b05ab459677e99ee20c~tplv-k3u1fbpfcp-watermark.awebp)

Taro 3 可理解为解释型架构，主要通过在小程序端模拟实现 DOM、BOM API 来让前端框架直接运行在小程序环境中，从而达到小程序和 H5 统一的目的，而对于生命周期、组件库、API、路由等差异，依然可以通过定义统一标准，各端负责各自实现的方式来进行抹平。这促使了在 Taro 3 中同时支持 React、Vue 等框架，甚至还支持了 jQuery

### taro-cli

[Taro 技术揭秘：taro-cli](https://juejin.cn/post/6844903633557913608)

### Taro框架开发相比原生开发有哪些不同

小程序原生的开发方式不够工程化
1.原生开发对Node、预编译器、webpack支持不好，影响开发效率和工程构建流程
2.微信定义了一个不伦不类的语法，不如正经学vue、react，学会了全端通用，而不是只为微信小程序
3.vue/react生态里有太多周边工具，可以提高开发效率，比如ide、校验器、三方库。。。
4.微信那个ide和专业编辑器相比实在不好用
> 一个小程序页面或组件，需要同时包含 4 个文件，以至开发一个功能模块时，需要多个文件间来回切换
> 没有自定义文件预处理，无法直接使用 Sass、Less 以及较新的 ES Next 语法
> 字符串模板太过孱弱，小程序的字符串模板仿的是 Vue，但是没有提供 Vue 那么多的语法糖，当实现一些比较复杂的处理时，写起来就非常麻烦，虽然提供了 wxs 作为补充，但是使用体验还是非常糟糕

### 小程序开发框架对比

#### 1.多端支持

Taro：支持微信的所有原生组件和api，无限制。同时框架封装了自己的跨端API，使用方式类似`Taro.request()`，支持Taro 代码与小程序代码混写，可通过混写的方式调用框架尚未封装的小程序新增API。
uni-app：支持微信的所有原生组件和api，无限制。在跨端方面，即便仍然使用微信原生的组件和API，也可以直接跨端编译到App、H5、以及支付宝百度头条等小程序。但为了管理清晰，推荐使用uni封装的API，类似`uni.request()`。同时支持条件编译，可在条件编译代码块中，随意调用各个平台新增的API及组件
mpvue：支持微信的所有原生组件和api，无限制。同时框架封装了自己的跨端API，使用方式类似 `mpvue.request()`
wepy：未对小程序API作二次封装，API依然使用微信原生的，框架与微信小程序是否新增API无关

Taro和uni-app在小程序端支持都不错，Taro发布移动端使用React Native，uni-app发布app端更容易也更多坑点
跨端支持度： `uni-app`,`Taro` > `mpvue` > `原生微信小程序`、`wepy`

#### 2.性能

setData回调函数开头可认为是页面渲染完成的时间

长列表加载，从页面空列表开始，每隔1秒触发一次上拉加载（新增20条微博），记录单次耗时，触发20次后停止（页面达到400条微博）
结果微信原生在这20次 `触发上拉 -> 渲染完成` 的平均耗时为876毫秒，最快的uni-app是741毫秒，最慢的mpvue是4493毫秒
微信原生框架耗时主要在setData调用上，开发者若不单独优化，则每次都会传递大量数据；
而 uni-app、Taro 都在调用setData之前自动做diff计算，每次仅传递变动的数据。

长列表中的点赞组件响应速度，点赞按钮 onclick函数开头开始计时，setData回调函数开头结束计时
组件数据更新性能测评：微信原生开发,uni-app,Taro > wepy > mpvue

性能结论：`微信原生开发手工优化`,`uni-app`>`微信原生开发未手工优化`,`Taro` > `wepy` > `mpvue`

#### 3.开发体验

React系用Taro，Vue系用uni-app
DSL语法支持：`Taro`,`uni-app` > `mpvue` > `wepy` > `微信原生`

### 使用过程遇到什么问题，怎么处理的

#### e.stopPropagation()无效

场景：在点击行时执行a事件后不让执行b事件
无效原因分析：Taro 为提高性能，有自己的一套事件处理机制，相当于将事件代理到全局进行处理，也就是说监听函数并未绑定到DOM元素上。
因此，如果你禁止Taro事件冒泡e.stopPropagation()，你就无法阻止原生事件冒泡；
你禁用原生事件冒泡e.nativeEvent.stopPropagation()，Taro的监听函数就调用不到了。
解决方式：判断event.target对象，是否是目标对象、或包含的对象、或被包含的对象，来决定是否触发事件。

## 参考资料

> 1. 掘金 关于Taro框架的几个面试点
>    <https://juejin.cn/post/6844904080649928712>
> 2. 掘金 小程序开发：用原生还是选框架（wepy/mpvue/uni-app/Taro）
>    <https://juejin.cn/post/6844903862504013832>
> 3. 掘金 驳《前端常见的Vue面试题目汇总》
>    <https://juejin.cn/post/6844904118704668685>
