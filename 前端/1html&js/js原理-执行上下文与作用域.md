# js原理-执行上下文与作用域

## 执行上下文

高程4.2 执行上下文与作用域

1. 变量或函数的上下文决定了它们可以访问那些数据，以及它们的行为
2. 每个上下文都有一个关联的 `变量对象 (variable object)`
   而这个上下文中定义的所有变量和函数都存在这个对象上。无法通过代码访问变量对象
3. 全局上下文是最外层的上下文。根据ECMAScript实现的宿主环境，表示全局上下文的对象可能不一样
   在浏览器中，全局上下文就是我们常说的window对象（第12章会详细介绍），
   所有通过var定义的全局变量和函数都会成为window对象的属性和方法
   使用let和const的顶级声明不会定义在全局上下文中，但在作用域解析上效果是一样的
4. 上下文在其所有代码都执行完毕后会销毁，包括定义在它上面的所有变量和函数
  （全局上下文在应用程序退出前才会销毁，比如关闭网页或退出浏览器）
   每个函数调用都有自己的上下文。当代码执行流进入函数时，函数的上下文被推到一个上下文栈
   在函数执行完之后，上下文栈会弹出该函数上下文，将控制权返回给之前的执行上下文。
   程序执行流就是通过这个上下文栈进行控制的
5. 上下文中的代码在执行的时候，会创建变量对象的一个 `作用域链（scope chain）`
   这个作用域链据决定了各级上下文的代码在访问变量和函数时的顺序
   代码正在执行的上下文的变量对象始终位于作用域链的最前端
   作用域链中的下一个变量对象来自包含上下文，再下一个对象来自再下一个包含上下文，
   以此类推至全局上下文。全局上下文的变量对象始终是作用域链的最后一个变量对象
   如果上下文是函数，则其 `活动对象 （activation object）`用作变量对象。
   活动对象最初只有一个定义变量:arguments(全局上下文没有)
6. 代码执行时的 `标识符解析` 是通过沿作用域链 `逐级搜索标识符名称` 完成的（变量或函数）。
   搜索过程始终从作用域链的最前端开始，然后逐级往后，直到找到标志符（没有找到就报错）
   内部上下文可以通过作用域链访问外部上下文中的一切，
   外部上下文无法访问内部上下文的任何东西。
   上下文之间的连接是线性的/有序的
   函数参数被认为是当前上下文中的变量，
   因此也跟上下文中的其他变量遵循相同的访问规则
7. 4.2.1 作用域链增强
   虽然执行上下文主要有 `全局上下文` 和 `函数上下文` 两种（eval()调用内部存在第三种上下文）
   但有其他方式来增强作用域链。
   `with` 语句会向作用域链前端添加指定的对象
   `catch` 语句会创建一个新的变量对象，这个变量对象会包含要抛出的错误对象的声明

